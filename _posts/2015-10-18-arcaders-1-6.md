---
layout: series_arcaders
title: "ArcadeRS 1.6: A moving rectangle"
categories: arcaders
nth: "sixth"
---

So far, we've setup the foundations that we will use throughout the rest of this
tutorial. Now that this is out of the way, we can get to the _good stuff_. In
this article, we are going to add a new view showing a rectangle. Nothing new
there, except for the fact that _the player will be able to control it_.

Once this is done, we will explore collision detection and ensure that the
player's ship cannot leave the screen. Because we want to support multiple
screen sizes, we will also handle window resizing.

Without further ado, let's get to it!


## The ship

Before anything else, you can clear the content of `views/mod.rs`. We will fill
it with more _interesting_ things throughout the rest of this chapter. The final
result will have the following structure:

```rust
use phi::{Phi, View, ViewAction};
use sdl2::pixels::Color;
use sdl2::rect::Rect as SdlRect;

// Constants

// Data types

// View definition
```

We will start from the very bottom by declaring a new view, called `GameView`:

```rust
/// The main view of our game, in which the player is able to control his ship,
/// which is currently represented by a rectangle.
pub struct GameView;

impl GameView {
    pub fn new(phi: &mut Phi) -> GameView {
        GameView
    }
}

impl View for GameView {
    fn render(&mut self, phi: &mut Phi, elapsed: f64) -> ViewAction {
        if phi.events.now.quit || phi.events.now.key_escape == Some(true) {
            return ViewAction::Quit;
        }

        // View logic here

        phi.renderer.set_draw_color(Color::RGB(0, 0, 0));
        phi.renderer.clear();

        // View rendering here

        ViewAction::None
    }
}
```

... which we immediately instantiate in `main.rs`:

```rust
::phi::spawn("ArcadeRS Shooter", |phi| {
    Box::new(::views::GameView::new(phi))
});
```

Nothing very impressive until now. However, it is time to create the cornerstone
of this article: the `Ship` data type:

```rust
/// The player's ship, currently represented by its bounding-box.
struct Ship {
    rect: Rectangle,
}
```

The `Rectangle` type will be used to represent the bounding box of every entity
in our game. It is defined as follows:

```rust
/// A simple rectangle with a position and dimensions, which can be transformed
/// into an SDL rectangle.
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Rectangle {
    pub x: f64,
    pub y: f64,
    pub w: f64,
    pub h: f64,
}
```

SDL has itself a concept of a rectangle: `sdl2::rect::Rect`, which we will
rename to `SdlRect` in order to highlight the differences between the two types.
The only issue with `SdlRect` is that it uses integral coordinates instead of
real ones, which won't be enough for our purposes.

For now, we will add only one method to `Rectangle`, allowing to bridge the gap
between the two code bases and render our bounding boxes during development:

```rust
impl Rectangle {
    /// Generates an SDL-compatible Rect equivalent to `self`.
    /// Panics if it could not be created, e.g. if the dimensions are negative.
    pub fn to_sdl(self) -> SdlRect {
        assert!(self.w >= 0.0 && self.h >= 0.0);
        SdlRect::new(self.x as i32, self.y as i32, self.w as u32, self.h as u32)
    }
}
```

If you compile this code, you shouldn't see much of a difference. This is due to
the fact that we have not yet added the ship to our view, nor rendered it. Let's
do that:

```rust
use phi::{Phi, View, ViewAction};
use sdl2::pixels::Color;
use sdl2::rect::Rect as SdlRect;


/// A simple rectangle with a position and dimensions, which can be transformed
/// into an SDL rectangle.
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Rectangle {
    pub x: f64,
    pub y: f64,
    pub w: f64,
    pub h: f64,
}

impl Rectangle {
    /// Generates an SDL-compatible Rect equivalent to `self`.
    /// Panics if it could not be created, e.g. if the dimensions are negative.
    pub fn to_sdl(self) -> SdlRect {
        assert!(self.w >= 0.0 && self.h >= 0.0);
        SdlRect::new(self.x as i32, self.y as i32, self.w as u32, self.h as u32)
    }
}


/// The player's ship, currently represented by its bounding-box.
struct Ship {
    rect: Rectangle,
}


/// The main view of our game, in which the player is able to control his ship,
/// which is currently represented by a rectangle.
pub struct GameView {
    player: Ship,
}

impl GameView {
    /// Create a new `GameView` with the ship on the point (64, 64), which is
    /// arbitrary, but does the job for now.
    pub fn new(phi: &mut Phi) -> GameView {
        GameView {
            player: Ship {
                rect: Rectangle { x: 64.0, y: 64.0, w: 32.0, h: 32.0 },
            }
        }
    }
}

impl View for GameView {
    /// Render and move the player's ship according to keyboard events.
    ///
    /// # TODO
    /// * Move the ship on keyboard events
    fn render(&mut self, phi: &mut Phi, elapsed: f64) -> ViewAction {
        // Quit the game if asked to
        if phi.events.now.quit || phi.events.now.key_escape == Some(true) {
            return ViewAction::Quit;
        }

        // [TODO] Insert the moving logic here

        // Clear the screen
        phi.renderer.set_draw_color(Color::RGB(0, 0, 0));
        phi.renderer.clear();

        // Render the scene
        phi.renderer.set_draw_color(Color::RGB(200, 200, 50));
        phi.renderer.fill_rect(self.player.rect.to_sdl()).unwrap();

        ViewAction::None
    }
}
```

There we go: this is our player's _ship_. You might notice this line:

```rust
phi.renderer.fill_rect(self.player.rect.to_sdl()).unwrap();
```

This is why the `to_sdl()` method is necessary. Something that might trouble
you, though, is the `unwrap()` at the end. If you take it off, you will get the
following warning:

```
warning: unused result which must be used, #[warn(unused_must_use)] on by default
    phi.renderer.fill_rect(self.player.rect.to_sdl());
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

This is simply Rust telling us that we should handle the case in which the
rectangle could not be drawn &mdash; for example, if the window crashed. In
which case, there is no point to continue rendering our scene and we panic. We
could also just ignore it with:

```rust
let _ = phi.renderer.fill_rect(self.player.rect.to_sdl());
```

Which is what you might want to do, but if this function were to fail, it would
be interesting to know why as we're developing our game.

Now, let's make this rectangle move!


## Movement

Wondered what the `elapsed` argument to `render` was all about? Well, the way we
defined it, it represents the amount of time that passed between the current
frame and the previous one, in seconds. Our objective is to have everything
moving at a constant speed, no matter the frame rate. This is where `elapsed`
comes into play!

Say you want the player's ship to translate by 180 pixels every second. Then,
you would define:

```rust
/// Pixels traveled by the player's ship every second, when it is moving.
const PLAYER_SPEED: f64 = 180.0;
```

Thus, when you want to compute the amount of pixels traveled by the ship, you
simply do:

```rust
let traveled = PLAYER_SPEED * elapsed;
```

Let's put this in practice. You can add the `PLAYER_SPEED` constant at the top
of the file. You will also want to handle the `key_left` and `key_right` events:

<!-- [ANCHOR] Here, we change the struct_events! syntax -->

```rust
struct_events! {
    keyboard: {
        key_escape: Escape,
        key_up: Up,
        key_down: Down,
        key_left: Left,
        key_right: Right,
        key_space: Space
    },
    else: {
        quit: Quit { .. }
    }
}
```

Now that `Events` knows about all four directional keys, we can move the ship:

```rust
// Move the player's ship
let diagonal =
    (phi.events.key_up ^ phi.events.key_down) &&
    (phi.events.key_left ^ phi.events.key_right);

let moved =
    if diagonal { 1.0 / 2.0f64.sqrt() }
    else { 1.0 } * PLAYER_SPEED * elapsed;

let dx = match (phi.events.key_left, phi.events.key_right) {
    (true, true) | (false, false) => 0.0,
    (true, false) => -moved,
    (false, true) => moved,
};

let dy = match (phi.events.key_up, phi.events.key_down) {
    (true, true) | (false, false) => 0.0,
    (true, false) => -moved,
    (false, true) => moved,
};

self.player.rect.x += dx;
self.player.rect.y += dy;
```

The code compiles, and it's a good sign: it means that our patterns are
_exhaustive_; that is, the compiler ensured that we covered all possible cases
in these `match` expressions.

On the third line, we are using the `^` (XOR, exclusive OR) symbol. It means:
"if and only if either of my arguments is `true`, but not both, then evaluate to
`true`". Its truth table is the following:

| A | B | A ^ B |
|:-:|:-:|:-----:|
| T | T |   F   |
| T | F |   T   |
| F | T |   T   |
| F | F |   F   |

In this context, it means: if we press either up or down, but not both at the
same time (which would make their effects cancel), then we are moving along this
axis. If we are moving along both axes, then the movement is diagonal. From
basic trigonometry, we know that

$$\sin(45°) = \cos(45°) = {\sqrt 2 \over 2} = {1 \over \sqrt 2}$$

Thus, when moving diagonally, the distance traveled in any direction is equal to

$${v \Delta t} \over \sqrt 2$$

<!--
You might start to understand why we needed to use floating-point values for our
coordinates. If not, then you should try to print out dx and dy:

```rust
println!("({}, {}) -> ({}, {})", dx, dy, dx as i32, dy as i32);

// (2.88, 0) -> (2, 0)
// (2.0364675298172568, 2.0364675298172568) -> (2, 2)
```

That is, when moving in diagonal, trimming doesn't do much. However, when
pressing only one directional key, we lose 88% of another pixel.
-->


## Bounding boxes

The next step is to prevent the player's ship from leaving the screen. To do so,
we will add a new method to the `Rectangle` type:

```rust
impl Rectangle {
    //? ...

    /// Return a (perhaps moved) rectangle contained by a `parent` rectangle.
    /// If it can indeed be moved to fit, then return `Some(child)`.
    /// If the container is too small, then return `None`.
    pub fn move_inside(self, parent: Rectangle) -> Option<Rectangle> {
        // It must be smaller than the parent rectangle to fit in it.
        if self.w > parent.w || self.h > parent.h {
            return None;
        }

        Some(Rectangle {
            w: self.w,
            h: self.h,
            x: if self.x < parent.x { parent.x }
               else if self.x + self.w >= parent.x + parent.w { parent.x + parent.w - self.w }
               else { self.x },
            y: if self.y < parent.y { parent.y }
               else if self.y + self.h >= parent.y + parent.h { parent.y + parent.h - self.h }
               else { self.y },
        })
    }
}
```

Equipped with this new method, we can now stuff back the player in the screen at
the end of the moving logic:

```rust
// If the player resizes the screen so that the ship can't fit in it
// anymore, then there is a problem and the game should be aborted.
self.player.rect = self.player.rect.move_inside(movable_region).unwrap();
```

It may seem silly to crash the program because the user made the screen too
small, however notice that the player cannot even resize the screen... yet.

<!--
It seems silly to crash the program, though, when most other applications just
define a minimum window size. It turns out that SDL also allows us to do this.
Let us get back to `src/phi/mod.rs` for a minute:

```rust
pub fn spawn<F>(title: &str, init_size: (u32, u32), min_size: (u32, u32), init: F)
where F: Fn(&mut Phi) -> Box<View> {
    // Initialize SDL2
    let sdl_context = ::sdl2::init().expect("Could not initialize SDL2");
    let video = sdl_context.video().expect("Could not load the video component");
    let mut timer = sdl_context.timer().unwrap();

    // Open the main window
    let mut window = video.window(title, init_size.0, init_size.1)
        .position_centered().opengl()
        .build().expect("Could not open the main window");

    window.set_minimum_size(min_size.0, min_size.1);
```
-->

Now, we just have to figure out what this _movable region_ is. In our game, the
player will face the right side of the screen, from which enemies will arrive.
As such, it seems appropriate to let the ship move from the top to the bottom of
the screen, and from the left of the screen to 70% of its width. This way, the
player cannot get to the far right of the screen where asteroids spawn and be
immediately obliterated.

Therefore, we would like to do something like this:

```rust
let movable_region = Rectangle {
    x: 0.0,
    y: 0.0,
    w: WINDOW_WIDTH * 0.70,
    h: WINDOW_HEIGHT,
};
```

We just have to figure out how to get the window's dimensions. Obviously, we
could just declare constants, but that wouldn't be very useful in the long run,
as we will make our game resizable in the next section.

It turns out that the window's `Renderer` exposes an `output_size` method, which
returns a `Result<(u32, u32)>`. Akin to our bounding box, we would like to get
those dimensions in a floating-point form. For this, we will add a new utility
method to `Phi`. In `src/phi/mod.rs`, you should add:

```rust
impl<'window> Phi<'window> {
    /// Get the size of the main window. If we cannot read the size, e.g. if the
    /// window has been closed, then we panic.
    pub fn output_size(&self) -> (f64, f64) {
        let (w, h) = self.renderer.output_size().unwrap();
        (w as f64, h as f64)
    }
}
```

Going back to `views/mod.rs`, we can finally compute `movable_region` and force
our player to stay in a definite region of the screen:

```rust
let movable_region = Rectangle {
    x: 0.0,
    y: 0.0,
    w: phi.output_size().0 * 0.70,
    h: phi.output_size().1,
};

// If the player resizes the screen so that the ship can't fit in it
// anymore, then there is a problem and the game should be aborted.
self.player.rect = self.player.rect.move_inside(movable_region).unwrap();
```

If you run your code, you should now get a controllable, yellowy rectangle which
can neither leave the frame nor go to its far right.

![A movable rectangle](/images/arcade-5.png)


## Window resizing

Now that we have ensured that the action is visible to the player, it is time to
allow said player to resize the game's window. For this, we will have to handle
yet another kind of event: window resizing.

Let us allow our window to be resized in the first place. In `src/phi/mod.rs`,
change the window's initialization to:

```rust
// Open the main window
let mut window = video.window(title, 800, 600)
    .position_centered().opengl().resizable()
    .build().expect("Could not open the main window");

window.set_minimum_size(480, 240)
    .expect("Could not set a minimum window size");
```

Not only does this allow our window to be resized, the last line also defines a
minimum size for our window, ensuring that the call to `unwrap` in `GameView`
will never cause a panic, unless the window already crashed.

Akin to other methods before it, `set_minimum_size` returns an `Err` if it is
unable to do its job &mdash; meaning that the desktop environment doesn't have
such a feature. You might choose to simply ignore this error and continue to run
the program as though nothing happened, but because this could lead to a crash
down the road, I prefer to report the error ASAP and handle it if it ever
becomes a problem in practice.

This works for our game, however it would be nice to allow users of the `phi`
library to choose which dimensions suit them best. For this, we must add new
arguments to `phi::spawn`:

```rust
pub fn spawn<F>(title: &str, init_size: (u32, u32), min_size: (u32, u32), init: F)
where F: Fn(&mut Phi) -> Box<View> {
    //? ...

    // Open the main window
    let mut window = video.window(title, init_size.0, init_size.1)
        .position_centered().opengl().resizable()
        .build().expect("Could not open the main window");

    window.set_minimum_size(min_size.0, min_size.1)
        .expect("Could not set a minimum window size");

    //? ...
}
```

Therefore, in `src/main.rs`, we should now have:

```rust
::phi::spawn("ArcadeRS Shooter", (800, 600), (480, 240), |phi| {
    Box::new(::views::GameView::new(phi))
});
```

If we wanted to make resizing optional, we may instead require that `min_size`
be an `Option`, where `None` means _not resizable_ and `Some` means _resizable
with those minimum dimensions_. For our purpose, this is unnecessary, but you
may wish to implement this for yourself. It's pretty straightforward and would
make your library slightly more versatile.

Let us now handle resizing events. A first attempt might be to exploit algebraic
data types and store the new dimensions in an event &mdash; this was my original
approach &mdash; however this isn't very useful, because `Phi` already comes
with a `output_size` method. As such, we can simply add new arguments to our
`struct_events!` macro:

```rust
struct_events! {
    keyboard: {
        //? ...
    },
    else: {
        quit: Quit { .. },
        resize: Window { win_event_id: Resized, .. }
    }
}
```

Now that this is done, you may run our updated program. You should notice that
we are able to resize the window, as long as we do not make it too small &mdash;
in which case, SDL will simply keep the window's size to the provided minimum.

![Resizing the window](/images/arcade-6.png)


## A library concern

Remember that Phi is all about putting our reusable components in one place, and
what would better fit this description than `Rectangle`? Because it doesn't feel
like it should have its place at the root of the library, yet isn't an event, it
is time to create a new file: `src/phi/data.rs`:

```rust
//? src/phi/mod.rs
//? There's a new module in town: data

#[macro_use]
mod events;
pub mod data;

//? ...
```

```rust
//? src/phi/data.rs

use sdl2::rect::Rect as SdlRect;


/// A simple rectangle with a position and dimensions, which can be transformed
/// into an SDL rectangle.
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Rectangle {
    pub x: f64,
    pub y: f64,
    pub w: f64,
    pub h: f64,
}

impl Rectangle {
    /// Generates an SDL-compatible Rect equivalent to `self`.
    /// Panics if it could not be created, e.g. if the dimensions are negative.
    pub fn to_sdl(self) -> SdlRect {
        assert!(self.w >= 0.0 && self.h >= 0.0);
        SdlRect::new(self.x as i32, self.y as i32, self.w as u32, self.h as u32)
    }

    /// Return a (perhaps moved) rectangle contained by a `parent` rectangle.
    /// If it can indeed be moved to fit, then return `Some(child)`.
    /// If the container is too small, then return `None`.
    pub fn move_inside(self, parent: Rectangle) -> Option<Rectangle> {
        // It must be smaller than the parent rectangle to fit in it.
        if self.w > parent.w || self.h > parent.h {
            return None;
        }

        Some(Rectangle {
            w: self.w,
            h: self.h,
            x: if self.x < parent.x { parent.x }
               else if self.x + self.w >= parent.x + parent.w { parent.x + parent.w - self.w }
               else { self.x },
            y: if self.y < parent.y { parent.y }
               else if self.y + self.h >= parent.y + parent.h { parent.y + parent.h - self.h }
               else { self.y },
        })
    }
}
```

```rust
//? src/views/mod.rs
//? Just take out the definition for `Rectangle` and `use` it instead.

use phi::{Phi, View, ViewAction};
use phi::data::Rectangle;
use sdl2::pixels::Color;

//? ...
```

In this file, we will store our general data structures, including `Rectangle`,
of course, but also other niceties such as resource pools. However, this is a
story for another time...


## Utility methods

We will also implement the following utility methods, which we will use to
implement sprite regions and collision detection. I let you figure out how
they work.

```rust
impl Rectangle {
    //? ...

    /// Check whether `self` is entirely contained in, or equal to, another
    /// rectangle passed as an argument.
    pub fn contains(&self, rect: Rectangle) -> bool {
        let xmin = rect.x;
        let xmax = xmin + rect.w;
        let ymin = rect.y;
        let ymax = ymin + rect.h;

        xmin >= self.x && xmin <= self.x + self.w &&
        xmax >= self.x && xmax <= self.x + self.w &&
        ymin >= self.y && ymin <= self.y + self.h &&
        ymax >= self.y && ymax <= self.y + self.h
    }

    /// Check whether some part of `self` overlaps with another rectangle, which
    /// is useful to detect collisions, for example.
    pub fn overlaps(&self, other: Rectangle) -> bool {
        self.x < other.x + other.w &&
        self.x + self.w > other.x &&
        self.y < other.y + other.h &&
        self.y + self.h > other.y
    }
}
```


## Conclusion

Well, this is what I would call a productive chapter! We jumped from a window
of a single color to a constrained, movable rectangle. It may not seem like it,
but our game is starting to take shape, and soon enough we will have a working
prototype.

In the [next article](/arcaders/arcaders-1-7), we will learn how to manage and
render images, or _sprites_.

And until then, keep rusting!

__[Snapshot on Github](https://github.com/jadpole/jadpole.github.io/blob/master/code/arcaders-1-6)__
