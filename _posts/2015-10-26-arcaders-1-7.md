---
layout: series_arcaders
title: "ArcadeRS 1.7: Sprites"
categories: arcaders
nth: "seventh"
---

In the previous article, we programmed a movable rectangle which was constrained
to the left of the screen. It does the job from a gameplay perspective but,
aesthetically, it's missing something: images. This is the problem that we are
going to tackle right now. In the process, we will learn about `Drop`, traits,
reference counting and, obviously, image rendering.

Let's go!


## A new library!

It is now time to add a new crate to our project:
[rust-sdl2_image](https://github.com/xsleonard/rust-sdl2_image). To do so,
change your `Cargo.toml` file so that you have the following dependencies:

```
[dependencies]
sdl2 = "0.24"
sdl2_image = "0.24"
```

Make sure that you have downloaded and appropriately placed the necessary
[development libraries](https://www.libsdl.org/projects/SDL_image), as with SDL2.

Akin to SDL2, this library must be initialized. And, like SDL2, it also relies
on a context object to clean up behind itself. As such, we can simply include
the `sdl2_image` crate in the `main.rs` file:

```rust
extern crate sdl2;
extern crate sdl2_image;
```

And then, in `phi/mod.rs`, initialize everything using `init()`:

```rust
pub fn spawn<F>(title: &str, init: F)
where F: Fn(&mut Phi) -> Box<View> {
    // Initialize SDL2
    let sdl_context = ::sdl2::init().unwrap();
    let video = sdl_context.video().unwrap();
    let mut timer = sdl_context.timer().unwrap();
    let _image_context = ::sdl2_image::init(::sdl2_image::INIT_PNG).unwrap();

    //? ...
}
```

Easy, isn't it? And it's all we need before we can finally use images. Before we
go any further, though, I would like to explore _how_ exactly `rust-sdl2_image`
and `rust-sdl2` can provide such an API.


## `Drop` and affine types

In the first article of this series, I briefly mentioned that:

> The nice thing about binding the context to an identifier is that, once it
> goes out of scope (at the end of the main method), all of the resources owned
> by the SDL library will be automatically freed. In fact, even if we panic at
> some point in the program, the destructor will still be called as usual [...]

I would like to expand on this.

As you might have heard before, Rust programs rely on affine types and RAII to
manage resources by default. This means, between other things, that the compiler
will automatically insert function calls to free resources that become
inaccessible. This is an area in which Rust and C++ are superior to
garbage-collected languages such as Java, not only performance-wise, but also in
the sense that you cannot accidentally leak a boxed value or forget to close a
file.

Both languages achieve this through the use of _destructors_. Those are functions
that are automatically called when a value gets out of scope, or when their
thread panics &mdash; this is why I say that `unwrap` _safely crashes_ the
program. In Rust, the destructor is implemented with `Drop`.

```rust
impl Drop for Sdl2ImageContext {
    fn drop(&mut self) {
        unsafe { ffi::IMG_Quit(); }
    }
}
```

This is similar to how `sdl_context` and the `video` handler are implemented.

When the compiler reaches a closing bracket:

```rust
{
    //? `my_value` is declared in this scope
    let my_value = new_value();

    //? The compiler reaches the end of the scope
}
```

It goes through every value that had been declared in that scope and checks
whether or not they have been _moved_. If that's the case, then Rust stops
caring about this value and whatever has taken ownership of it has the
responsibility to call its destructor.

However, if the value is still in scope, then the compiler will automatically
"insert" a call to `drop()`. Conceptually, you can think of it as:

```rust
{
    let my_value = new_value();

    //? We reach the end of the scope
    //? Has the value been moved? Nope! Therefore, drop it:
    my_value.drop();

    //> error: explicit use of destructor method [E0040]
    //>     _image_context.drop();
    //>                    ^~~~~~
}
```

If you try to compile similar code, you might notice that you simply cannot drop
a value manually. To understand why, you simply have to look at the definition
of the [`Drop` trait](https://doc.rust-lang.org/std/ops/trait.Drop.html):

```rust
trait Drop {
    fn drop(&mut self);
}
```

That is, `drop()` is not actually moving the value. This is mostly a performance
optimization, because whenever `drop` is inserted, the compiler is sure that it
will not be used by anything else. Passing a pointer is therefore appropriate.
If you _really_ wish to free a value manually (which I have never had to do in
practice), you can use [`std::mem::drop`](https://doc.rust-lang.org/std/mem/fn.drop.html),
which would indeed _move_ `my_value`.


## Let `Phi` initialize itself

Let us come back to the `Phi` type:

```rust
pub struct Phi<'window> {
    pub events: Events,
    pub renderer: Renderer<'window>,
}

impl<'window> Phi<'window> {
    pub fn output_size(&self) -> (f64, f64) {
        let (w, h) = self.renderer.output_size().unwrap();
        (w as f64, h as f64)
    }
}
```

For the moment it is quite simple. In fact, we can easily create it from within
`spawn`, as we have been doing up to now:

```rust
// Create the context
let mut context = Phi {
    events: Events::new(sdl_context.event_pump().unwrap()),
    renderer: window.renderer()
        .accelerated()
        .build().unwrap(),
};
```

However, as our library becomes more complex, we would like `Phi` to take care
of some optimizations, such as caching fonts in
[the ninth article](http://localhost:4000/arcaders/arcaders-1-9). This would
mean cluttering `spawn` with an initialization process that it shouldn't have to
know or care about. What we would like is to replace the previous structure
initalization by a function call:

```rust
// Create the context
let mut context = Phi::new(
    Events::new(sdl_context.event_pump().unwrap()),
    window.renderer()
        .accelerated()
        .build().unwrap());
```

Indeed, you should change that right now! If you try to compile your code
afterwards, it probably isn't going to work, because

```
error: no associated item named `new` found for type `phi::Phi<'_>` in the current scope
    let mut context = Phi::new(
                      ^~~~~~~~
```

We can fix this quite simply by moving the initialization logic to a new static
method which we will call `new`:

```rust
impl<'window> Phi<'window> {
    fn new(events: Events, renderer: Renderer<'window>) -> Phi<'window> {
        Phi {
            events: events,
            renderer: renderer,
        }
    }

    //? ...
}
```

Notice that we did not make `Phi::new` public. This is because we do not want to
allow users of our library to create their own context. If they did, the
sdl2_image library could be freed at any moment, and we would lose the
guarantees that we are striking for.

Alright, it's time to load some images!


## Loading images

Rust has this feature where it allows you to implement a trait on a type that
you do not own. More specifically, there are two situations in which you are
allowed to implement a trait. You must either own the _trait_ that you are about
to implement...

```rust
trait MyCustomTrait {
}

impl MyCustomTrait for String {
}
```

... or you should own the _type_ on which you are implementing the trait ...

```rust
struct MyCustomType;

impl Hash for MyCustomType {
    // ...
}
```

In either case, if the trait and the type exist in different crates, then it is
necessary to `use` the trait for it to become _active_. Let's see how this works
in practice!

The sdl2\_image library uses this feature to implement a trait called
`LoadTexture` on `Renderer`. It is through it that we will be able to load
external images into our game.

Let's edit `views/mod.rs`. First of all, we need to `use` the trait. We'll also
import other components to save keystrokes:

```rust
use phi::{Phi, View, ViewAction};
use phi::data::Rectangle;
use std::path::Path;
use sdl2::pixels::Color;
use sdl2::render::{Texture, TextureQuery};
use sdl2_image::LoadTexture;
```

![A spaceship](/images/spaceship.png)

This is the spritesheet that we will use to represent our player's ship. I
suggest that you store it in a new directory at the root of your project as
`assets/spaceship.png`. From now on, you should run your game from the root
of your project in order for the process to find the assets.

Let's now modify `Ship` to store this _texture_ (SDL's concept of an image)
alongside its bounding box:

```rust
struct Ship {
    rect: Rectangle,
    tex: Texture,
}
```

Next, we load it whenever the view is instantiated:

```rust
impl ShipView {
    pub fn new(phi: &mut Phi) -> ShipView {
        //? Load the texture from the filesystem.
        //? If it cannot be found, then there is no point in continuing: panic!
        let tex = phi.renderer.load_texture(Path::new("assets/spaceship.png")).unwrap();

        //? Destructure some properties of the texture, notably width and
        //? height, which we will use for the ship's bounding box.
        let TextureQuery { width, height, .. } = tex.query();

        ShipView {
            player: Ship {
                rect: Rectangle {
                    x: 64.0,
                    y: 64.0,
                    w: width as f64,
                    h: height as f64,
                },
                tex: tex,
            }
        }
    }
}
```

Now, for _rendering_ the image (in `ShipView::render`):

```rust
//? This was previously there:
// Render the bounding box (for debugging purposes)
phi.renderer.set_draw_color(Color::RGB(200, 200, 50));
phi.renderer.fill_rect(self.player.rect.to_sdl().unwrap()).unwrap();

//? We add this part:
// Render the ship
//? The texture to render is `self.player.tex` (we borrow it mutably)
phi.renderer.copy(&mut self.player.tex,
    //? The "source region" of the image. Here, we take the entire image, from
    //? the top-left corner (0,0) to the bottom-right one (rect.w, rect.h).
    Rectangle {
        x: 0.0,
        y: 0.0,
        w: self.player.rect.w,
        h: self.player.rect.h,
    }.to_sdl(),
    //? The destination of the image. We simply provide the bounding box, the
    //? renderer takes care of the rest.
    self.player.rect.to_sdl())
    .unwrap();
```

![The spritesheet and its bounding box](/images/arcade-8.png)


## Frames

We managed to render an image, however most of the time this is not what we
intend to do, our spaceship being an obvious example. What we want is to render
a single frame of the image, say the middle-left one.

For our ship, any frame is 43x39 pixels, for a total of 129x117 pixels, so we
may render the middle-left frame with:

```rust
phi.renderer.copy(&mut self.player.tex,
    Rectangle {
        x: 43.0 * 0.0,
        y: 39.0 * 1.0,
        w: self.player.rect.w,
        h: self.player.rect.h,
    }.to_sdl(),
    self.player.rect.to_sdl())
    .unwrap();
```

Assuming, of course, that the bounding box `player.rect` now has a width of 43
and a height of 39. More generally, we can write:

```rust
/// Pixels traveled by the player's ship every second, when it is moving.
const PLAYER_SPEED: f64 = 180.0;

const SHIP_W: f64 = 43.0;
const SHIP_H: f64 = 39.0;

// ...

impl ShipView {
    pub fn new(phi: &mut Phi) -> ShipView {
        ShipView {
            player: Ship {
                rect: Rectangle {
                    x: 64.0,
                    y: 64.0,
                    w: SHIP_W,
                    h: SHIP_H,
                },
                tex: phi.renderer.load_texture(Path::new("assets/spaceship.png")).unwrap(),
            }
        }
    }
}

// ...

phi.renderer.copy(&mut self.player.tex,
    Rectangle {
        x: SHIP_W * 0.0,
        y: SHIP_H * 1.0,
        w: self.player.rect.w,
        h: self.player.rect.h,
    }.to_sdl(),
    self.player.rect.to_sdl())
    .unwrap();
```

![Only one frame of the ship](/images/arcade-9.png)

Hopefully, you get the idea. What we want to do now is describe those _regions_
with a structure that allows us to render them without copying the spritesheet
over and over again. We will call those regions _sprites_.


## Sprites and regions

This is where reference counting comes into play. The basic idea is simple:
every _copy_ of our object references the same immutable structure. When we
`clone` it, we increment an integer indicating the number of copies; when we
`drop` it, we decrement that number. When the counter becomes zero, we `drop`
the shared value.

We will use the standard library's `Rc` (<b>R</b>eference <b>c</b>ounted) type
for this task.

However, although we never change the texture, we must pass a mutable reference
to the `Renderer::copy` method. To do so, we need one more piece of machinery:
_interior mutability_. Rust provides the `RefCell` type. It checks at runtime
that there only exists one mutable reference to its content. In exchange, it
allows us to reference-count a mutable value.

Let us create a new file: `phi/gfx.rs` (for _graphics_). In it, we will define
the `Sprite` type:

```rust
use phi::data::Rectangle;
use std::cell::RefCell;
use std::path::Path;
use std::rc::Rc;
use sdl2::render::{Renderer, Texture};
use sdl2_image::LoadTexture;


#[derive(Clone)]
pub struct Sprite {
    tex: Rc<RefCell<Texture>>,
    src: Rectangle,
}
```

By using `#[derive(Clone)]`, we tell the compiler to automatically implement the
`Clone` trait for us. It is equivalent to:

```rust
impl Clone for Sprite {
    fn clone(&self) -> Sprite {
        Sprite {
            tex: self.tex.clone(),
            src: self.src.clone(),
        }
    }
}
```

If some attribute of our type did not implement `Clone`, then the compiler would
complain and we would have to implement it manually. In this case, however,
everything works as expected.

Before we move on, you should probably declare this module in `phi/mod.rs`:

```rust
#[macro_use]
mod events;
pub mod data;
pub mod gfx;
```

It is straightforward to add a `load` method to `Sprite`, which will allow us to
get an image from a file. For good measure, we also implement a `new` method,
which will take in a texture and wrap it, similarly to what we did in
`ShipView`'s constructor. Notice how we chain the
[`Result::ok`](https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.ok) and
[`Option::map`](https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.map)
methods in `Sprite::load`.

```rust
impl Sprite {
    /// Creates a new sprite by wrapping a `Texture`.
    pub fn new(texture: Texture) -> Sprite {
        let tex_query = texture.query();

        Sprite {
            tex: Rc::new(RefCell::new(texture)),
            src: Rectangle {
                w: tex_query.width as f64,
                h: tex_query.height as f64,
                x: 0.0,
                y: 0.0,
            }
        }
    }

    /// Creates a new sprite from an image file located at the given path.
    /// Returns `Some` if the file could be read, and `None` otherwise.
    pub fn load(renderer: &Renderer, path: &str) -> Option<Sprite> {
        renderer.load_texture(Path::new(path)).ok().map(Sprite::new)
    }
}
```

Now, we can tackle `Sprite`'s main feature: `region`. This is where the magic
happens. First, we want to verify that the requested region is part of our
existing sprite. Then, we want to return the new sprite corresponding to this
subregion. Here's how I did it:

```rust
    /// Returns a new `Sprite` representing a sub-region of the current one.
    /// The provided `rect` is relative to the currently held region.
    /// Returns `Some` if the `rect` is valid, i.e. included in the current
    /// region, and `None` otherwise.
    pub fn region(&self, rect: Rectangle) -> Option<Sprite> {
        let new_src = Rectangle {
            x: rect.x + self.src.x,
            y: rect.y + self.src.y,
            ..rect
        };

        // Verify that the requested region is inside of the current one
        if self.src.contains(new_src) {
            Some(Sprite {
                tex: self.tex.clone(),
                src: new_src,
            })
        } else {
            None
        }
    }
```

As a side note, the `T { modifications, ..original }` syntax is equivalent to:

```rust
let new_src = Rectangle {
    x: rect.x + self.src.x,
    y: rect.y + self.src.y,
    w: rect.w,
    h: rect.h,
};
```

That is, if `rect.w` did not implement `Copy` (which, fortunately, it does),
then the `w` attribute would be _moved_ and `rect` would be made invalid.

We will also add a `size` method so that users of our type can query the
region's dimensions:

```rust
    // Returns the dimensions of the region.
    pub fn size(&self) -> (f64, f64) {
        (self.src.w, self.src.h)
    }
```

Most of the work on `Sprite` is already done. The last step is to add the
`render` method:

```rust
impl Sprite {
    // ...

    pub fn render(&self, renderer: &mut Renderer, dest: Rectangle) {
        renderer.copy(&mut self.tex.borrow_mut(), self.src.to_sdl(), dest.to_sdl()).unwrap()
    }
}
```

Now, let's use it!


## Rendering the whole spritesheet

Let's get back to `views/mod.rs` and import the required components:

```rust
use phi::{Phi, View, ViewAction};
use phi::data::Rectangle;
use phi::gfx::Sprite;
use sdl2::pixels::Color;
```

Next, we update our ship and it's instantiation:

```rust
struct Ship {
    rect: Rectangle,
    sprite: Sprite,
}

//? ...

impl ShipView {
    pub fn new(phi: &mut Phi) -> ShipView {
        let sprite = Sprite::load(&mut phi.renderer, "assets/spaceship.png").unwrap();
        let (w, h) = sprite.size();

        ShipView {
            player: Ship {
                rect: Rectangle {
                    x: 64.0,
                    y: 64.0,
                    w: w,
                    h: h,
                },
                sprite: sprite,
            }
        }
    }
}
```

Finally, we render the sprite:

```rust
// Render the ship
self.player.sprite.render(&mut phi.renderer, self.player.rect);
```

You should get the same result as we did in _Loading images_.

![The spritesheet and its bounding box](/images/arcade-8.png)


## Individual frames and input

If sprites were simply an alternative way to render textures, they would be
quite boring. Fortunately, as we've been saying for some time already, they
shine at rendering _regions_. Let us first define a new `enum` to represent the
different states our ship might be in:

```rust
/// The different states our ship might be in. In the image, they're ordered
/// from left to right, then from top to bottom.
#[derive(Clone, Copy)]
enum ShipFrame {
    UpNorm   = 0,
    UpFast   = 1,
    UpSlow   = 2,
    MidNorm  = 3,
    MidFast  = 4,
    MidSlow  = 5,
    DownNorm = 6,
    DownFast = 7,
    DownSlow = 8
}
```

We will change our ship's definition so that it can hold all possible sprites:

```rust
struct Ship {
    rect: Rectangle,
    sprites: Vec<Sprite>,
    current: ShipFrame,
}
```

Now, for the view's constructor:

```rust
impl ShipView {
    pub fn new(phi: &mut Phi) -> ShipView {
        let spritesheet = Sprite::load(&mut phi.renderer, "assets/spaceship.png").unwrap();

        //? When we know in advance how many elements the `Vec` we contain, we
        //? can allocate the good amount of data up-front.
        let mut sprites = Vec::with_capacity(9);

        for y in 0..3 {
            for x in 0..3 {
                sprites.push(spritesheet.region(Rectangle {
                    w: SHIP_W,
                    h: SHIP_H,
                    x: SHIP_W * x as f64,
                    y: SHIP_H * y as f64,
                }).unwrap());
            }
        }

        ShipView {
            player: Ship {
                rect: Rectangle {
                    x: 64.0,
                    y: 64.0,
                    w: SHIP_W,
                    h: SHIP_H,
                },
                sprites: sprites,
                current: ShipFrame::MidNorm,
            }
        }
    }
}
```

Then, we select which sprite to show based on the movement of the ship:

```rust
//? Add just after the call to `move_inside`

// Select the appropriate sprite of the ship to show.
self.player.current =
    if dx == 0.0 && dy < 0.0       { ShipFrame::UpNorm }
    else if dx > 0.0 && dy < 0.0   { ShipFrame::UpFast }
    else if dx < 0.0 && dy < 0.0   { ShipFrame::UpSlow }
    else if dx == 0.0 && dy == 0.0 { ShipFrame::MidNorm }
    else if dx > 0.0 && dy == 0.0  { ShipFrame::MidFast }
    else if dx < 0.0 && dy == 0.0  { ShipFrame::MidSlow }
    else if dx == 0.0 && dy > 0.0  { ShipFrame::DownNorm }
    else if dx > 0.0 && dy > 0.0   { ShipFrame::DownFast }
    else if dx < 0.0 && dy > 0.0   { ShipFrame::DownSlow }
    else { unreachable!() };
```

Notice the call to `unreachable!()` at the end of our conditional. This is a way
of telling the compiler: look! I know you cannot verify that I covered every
possibility but, trust me, I did. If an unreachable is somehow reached, the
thread will panic.

Finally, we render the ship:

```rust
// Render the ship
self.player.sprites[self.player.current as usize]
    .render(&mut phi.renderer, self.player.rect);
```

If everything went well, you should get the following result:

![A moving ship](/images/arcade-10.gif)

Pretty cool, eh?


## Renderer::copy_sprite()

What we got so far is quite interesting, however there is still something
missing, not functionality-wise, but ergonomics-wise. You see, we typically do
not think of a sprite _rendering_ itself, but of a `renderer` taking care of
this task. Remember when I talked about sdl2\_image implementing a custom trait
on `Renderer`? Well, we're going to do the same thing!

In `phi/gfx.rs`, we're going to declare and implement the following trait:

```rust
pub trait CopySprite {
    fn copy_sprite(&mut self, sprite: &Sprite, dest: Rectangle);
}

impl<'window> CopySprite for Renderer<'window> {
    fn copy_sprite(&mut self, sprite: &Sprite, dest: Rectangle) {
       sprite.render(self, dest);
   }
}
```

We must then use it in `views/mod.rs` to render our ship:

```rust
use phi::gfx::{CopySprite, Sprite};

//? ...

// Render the ship
phi.renderer.copy_sprite(
    &self.player.sprites[self.player.current as usize],
    self.player.rect);
```

Depending on your preferences, you might decide to use the previous version. As
with pineapples, nothing stops you from doing so &mdash; simply note that I will
use this form from now on.


## Conclusion

Well, this article was quite a ride, wasn't it! The [next one](/arcaders/arcaders-1-8)
should go much smoother, as we use our trusty `Sprite` once again to animate
backgrounds and a foreground.

Until then, keep rusting!


__[Snapshot on Github](https://github.com/jadpole/jadpole.github.io/blob/master/code/arcaders-1-7)__
