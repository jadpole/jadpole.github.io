---
layout: post
title: "Dealing with multiple error types in Rust"
categories: rust
---

If you've read [ArcadeRS](#), you know that I quite enjoy the way in which Rust
deals with error handling &mdash; that is, through its type-system and the
`Result` type. However, if you attempted to manage errors coming from different
sources (and thus of different kinds), you may have found the experience kinda
weird at first.

> NOTE: I'm using code from the next update of ArcadeRS, which uses a slightly
> different approach from the current one. You do not need to follow the series,
> however, to understand this article.

We will consider the use of AngryLawyer's SDL2 wrapper when initializing the Phi
library. Here's the deal: we need to create a new object that contains an event
pump and a renderer. Both are declared by SDL2 and both initializations can fail,
however the cause for such a failure is different in either case. As such, both
operations return a different error type.

More specifically, we want to define an associated function `Phi::new` such that:

```rust
/// Bundles the Phi abstractions in a single structure which can be passed
/// easily between functions.
pub struct Phi<'window> {
    pub events: Events,
    pub renderer: Renderer<'window>,
}

impl<'window> Phi<'window> {
    /// Initialize the Phi context from SDL2 components.
    pub fn new(sdl_context: &::sdl2::Sdl, window: Window) -> Result<Phi, ???> {
        Ok(Phi {
            events: Events::new(try!(sdl_context.event_pump())),
            renderer: try!(window.renderer().accelerated().build()),
        })
    }
}
```

Except that (for obvious reasons) this does not compile! We do not want to deal
with the errors possibly generated by `event_pump()` and `build()`; all we wish
to do for now is to propagate them. However, as I mentioned, they use different
error types:

```rust
#[derive(Debug)]
pub enum IntegerOrSdlError {
    IntegerOverflows(&'static str, u32),
    SdlError(String)
}

pub fn build(self) -> Result<Renderer<'static>, IntegerOrSdlError>;
pub fn event_pump(&self) -> Result<EventPump, String>;
```

You may manually `match`, wrap and return the errors, but it would be nice to
keep using `try!` (or the `?` operator) instead of getting back to the stone age
every time we want to do anything non-trivial. Although the answer here is
obvious once you give some thought to it, there doesn't seem to be much
documentation on how to propagate heterogeneous errors in a _rustic_ way, so
here's my take on it.


## 1. Define a common error type

The first step if we want to handle different error types is to combine them in
an enumeration. Because we're building a library called _phi_, we will call the
compound type `PhiError`:

```rust
/// A wrapper for all of the error that may be returned by the Phi library.
#[derive(Debug)]
pub enum PhiError {
    IntegerOverflows(&'static str, u32),
    SdlError(String),
}
```

<!--
```
impl ::std::error::Error for PhiError {
    fn description(&self) -> &str {
        match *self {
            PhiError::IntegerOverflows(_, _) => "integer overflow",
            PhiError::SdlError(ref descr) => descr,
        }
    }
}
```

You might notice that this definition is quite similar to [CrumblingStatue's](https://github.com/AngryLawyer/rust-sdl2/blob/c2747e706049fde4b679800675f74b6602607055/src/sdl2/common.rs#L41-L50)
implementation. That's kind of the point: although this process can be repeated
for all possible errors that may occur in the library, for now, we are basically
wrapping _rust-sdl2_'s error types.
-->

Our `new` method now looks like this:

```rust
impl<'window> Phi<'window> {
    /// Initialize the Phi context from SDL2 components.
    pub fn new(sdl_context: &::sdl2::Sdl, window: Window) -> Result<Phi, PhiError> {
        Ok(Phi {
            events: Events::new(try!(sdl_context.event_pump())),
            renderer: try!(window.renderer().accelerated().build()),
        })
    }
}
```


## 2. Wrap other errors

Now that we have a common type to return from `Phi::new`, we want to convert SDL
results to our own. To do this, we will add a few useful associated functions to
`PhiError`:

```rust
impl PhiError {
    pub fn from_int_or_sdl<T>(result: Result<T, IntegerOrSdlError>) -> Result<T, PhiError> {
        match result {
            Ok(value) => Ok(value),

            Err(IntegerOrSdlError::IntegerOverflows(name, value)) =>
                Err(PhiError::IntegerOverflows(name, value)),

            Err(IntegerOrSdlError::SdlError(err_msg)) =>
                Err(PhiError::SdlError(err_msg)),
        }
    }

    pub fn from_sdl<T>(result: Result<T, String>) -> Result<T, PhiError> {
        match result {
            Ok(value) => Ok(value),
            Err(err_msg) => Err(PhiError::SdlError(err_msg)),
        }
    }
}
```

This may seem like a lot of work, however this solution has the advantage of
being easily extensible. Moreover, it makes error propagation in `Phi::new`
pretty straightforward:

```rust
impl<'window> Phi<'window> {
    /// Initialize the Phi context from SDL2 components.
    pub fn new(sdl_context: &::sdl2::Sdl, window: Window) -> Result<Phi, PhiError> {
        Ok(Phi {
            events: Events::new(try!(PhiError::from_sdl(sdl_context.event_pump()))),
            renderer: try!(PhiError::from_int_or_sdl(window.renderer().accelerated().build())),
        })
    }
}
```

An even better solution would be to do something like this:

```rust
use std::convert::From;

type PhiResult<T> = Result<T, PhiError>;

impl<T> From<Result<T, IntegerOrSdlError>> for PhiResult<T> {
    fn from(result: Result<T, IntegerOrSdlError>) -> PhiResult<T> {
        match result {
            Ok(value) => Ok(value),

            Err(IntegerOrSdlError::IntegerOverflows(name, value)) =>
                Err(PhiError::IntegerOverflows(name, value)),

            Err(IntegerOrSdlError::SdlError(err_msg)) =>
                Err(PhiError::SdlError(err_msg)),
        }
    }
}

impl<T> From<Result<T, String>> for PhiResult<T> {
    fn from(result: Result<T, String>) -> PhiResult<T> {
        match result {
            Ok(value) => Ok(value),
            Err(err_msg) => Err(PhiError::SdlError(err_msg)),
        }
    }
}

impl<'window> Phi<'window> {
    /// Initialize the Phi context from SDL2 components.
    pub fn new(sdl_context: &::sdl2::Sdl, window: Window) -> Result<Phi, PhiError> {
        Ok(Phi {
            events: Events::new(try!(PhiResult::from(sdl_context.event_pump()))),
            renderer: try!(PhiResult::from(window.renderer().accelerated().build())),
        })
    }
}
```

Or even better:

```rust
macro_rules! phi_try {
    [ $maybe:expr ] => {
        try!(::phi::PhiResult::from($maybe))
    }
}

impl<'window> Phi<'window> {
    /// Initialize the Phi context from SDL2 components.
    pub fn new(sdl_context: &::sdl2::Sdl, window: Window) -> Result<Phi, PhiError> {
        Ok(Phi {
            events: Events::new(phi_try!(sdl_context.event_pump())),
            renderer: phi_try!(window.renderer().accelerated().build()),
        })
    }
}
```

However, Rust does not currently allow one to implement foreign traits on
foreign generic types, even if we set `E` in `Result<T, E>` to a custom type.
Thus, we shall stick to `PhiError::from_int_or_sdl` and friends for now.


## 3. Profit

With this simple scaffolding out of the way, it is trivial to combine errors of
many kinds and propagate them through the program. Moreover, this makes things
even easier for users and colleagues, because they do not have to care about all
of the complexities of SDL2, or whatever library you're using for your project.

Perhaps most importantly, it reduces the envy to just _stick an_ `unwrap` _and
call it a day_ &mdash; which, to be honest, is probably what the users of
`Phi::new` will do anyway (indeed, that's my approach in ArcadeRS).

Oh well!
